{
  "categories": {
    "architecture": {
      "title": "Architecture",
      "summary": "This category summarizes best practices regarding architecture.",
      "slug": "architecture",
      "items": [
        "Z2guUQd",
        "Z1ohpIo",
        "1pQWxn",
        "NEzhm",
        "Z2qKc11",
        "Z1eHhoR"
      ]
    },
    "components": {
      "title": "Components",
      "summary": "This category summarizes best practices regarding Components.",
      "slug": "components",
      "items": [
        "2eREkv",
        "2rF4Hq",
        "ZXcqct",
        "ZXTLWo",
        "Z1eEvQQ"
      ]
    },
    "general": {
      "title": "General",
      "summary": "This category summarizes best practices regarding general topics.",
      "slug": "general",
      "items": [
        "1KaHiT"
      ]
    },
    "http": {
      "title": "HTTP",
      "summary": "This category summarizes best practices regarding HTTP interactions and modules.",
      "slug": "http",
      "items": [
        "2oN0jv"
      ]
    },
    "ngrx": {
      "title": "NgRx",
      "summary": "This category summarizes best practices regarding NgRx.",
      "slug": "ngrx",
      "items": [
        "Z2exNXo",
        "iglD3",
        "ZPhLz2",
        "1kimRN",
        "ZlteSK",
        "1t4mCT",
        "Myhw4"
      ]
    },
    "performance": {
      "title": "Performance",
      "summary": "This category contains a list of practices which will help us boost the performance of our Angular applications. It covers different topics - from server-side pre-rendering and bundling of our applications, to runtime performance and optimization of the change detection performed by the framework.",
      "slug": "performance",
      "items": [
        "ZfxFUd",
        "CjbpO",
        "FGjYL"
      ]
    },
    "router": {
      "title": "Router",
      "summary": "This category summarizes best practices regarding routing.",
      "slug": "router",
      "items": [
        "Zy4xtr",
        "5ScV4",
        "Z165VzV",
        "Z2nRe1e",
        "lGMp8"
      ]
    },
    "rxjs": {
      "title": "RxJS",
      "summary": "This category summarizes best practices regarding RxJS.",
      "slug": "rxjs",
      "items": [
        "Z1eFwa9",
        "ZzpwmT",
        "Iqkhs",
        "Z3uGQp",
        "fztee",
        "Z1vCEKO"
      ]
    },
    "tooling": {
      "title": "Tooling",
      "summary": "This category summarizes best practices regarding tooling.",
      "slug": "tooling",
      "items": [
        "Z1uf1Rj",
        "Z2fVpC5",
        "PWWcx"
      ]
    },
    "typescript": {
      "title": "Typescript",
      "summary": "This category summarizes best practices regarding Typescript.",
      "slug": "typescript",
      "items": [
        "Z2hzSxp",
        "23KPo0",
        "12Aq23",
        "ZRBVWY",
        "ZEhkug"
      ]
    }
  },
  "items": {
    "Z2guUQd": {
      "id": "Z2guUQd",
      "slug": "never-mutate-objects",
      "category": "architecture",
      "title": "never mutate objects and embrace immutability",
      "content": "<h3>Problem</h3>\n<p>Performing a deep comparison of objects in JavaScript is a quite costly operation. Reference checks however, are extremely fast and easy. For that reason, Angular and lots of other libraries depend on reference check comparisons instead of deeply comparing objects. If you mutate objects, you most likely experience weird and unexpected behavior when using any of these libs.</p>\n<p>Here are some examples of things that don’t work properly when mutating objects are:</p>\n<ul>\n<li><code>OnPush</code> ChangeDetectionStrategy in Angular</li>\n<li>NgRx selectors</li>\n<li>RxJS operators such as <code>distinct</code>, <code>distinctUntilChanged</code>, <code>tap</code>, …</li>\n</ul>\n<h3>Solution</h3>\n<p>Instead of mutating objects, we need to work immutable. Immutability means that we will never mutate objects. Instead, if we need to update state or some object properties, we first copy the object and then make our changes.</p>\n<p>This can easily be done with the object/array spread operator:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// Original State</span>\n<span class=\"hljs-keyword\">const</span> state = {\n  users: [\n    { id: <span class=\"hljs-number\">1</span>, name: <span class=\"hljs-string\">\"Dominic Elm\"</span> },\n    { id: <span class=\"hljs-number\">2</span>, name: <span class=\"hljs-string\">\"Kwinten Pisman\"</span> },\n  ],\n  selectedUserId = <span class=\"hljs-number\">1</span>\n}\n\n<span class=\"hljs-comment\">// New State</span>\n<span class=\"hljs-keyword\">const</span> newState = { ...state, selectedUserId: <span class=\"hljs-number\">2</span> };\n</code></pre>\n<p>In this example, we have a state object with some data. We want to update the <code>selectedUserId</code> property, without mutating the original object. Using the object spread operator, we create a new object, keeping the same reference to the <code>users</code> array but updating the <code>selectedUserId</code> to 2.</p>\n<p><strong>Note:</strong> This is just one of the ways we can work immutable. The spread operator is available in the latest versions of JavaScript. There are also libraries that can help us to work immutable that will be more performant for big collections, for example <a href=\"https://facebook.github.io/immutable-js/\">Immutable.js</a>, <a href=\"https://github.com/mweststrate/immer\">Immer</a> or <a href=\"https://github.com/rtfeldman/seamless-immutable\">Seamless Immutable</a>. The point here is that we should embrace immutability and try to avoid mutating objects, regardless of how you accomplish this.</p>\n"
    },
    "Z1ohpIo": {
      "id": "Z1ohpIo",
      "slug": "provide-shared-services-on-root-level",
      "category": "architecture",
      "title": "provide shared services only on root level",
      "content": "<h3>Problem</h3>\n<p>Due to the way DI (Dependency Injection) in Angular is implemented, with an injector tree, we can provide instances of our service on multiple levels, e.g. component, directive or module. While this is a useful feature, this is not always what we want.</p>\n<p>Working with a shared module is quite common and recommended. This module can be used to share services, components, directives, pipes, etc. between different feature modules. If we import our shared module in multiple modules, we will provide the service multiple times and multiple instances will be created. Our services are no longer singletons.</p>\n<h3>Solution</h3>\n<p>When creating a <code>SharedModule</code>, we want to import the components in all feature modules but only provide the services in our root module, for instance <code>AppModule</code>. We can accomplish this by leveraging the <code>forRoot</code> convention. Here’s what our <code>SharedModule</code> would look like this:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@NgModule</span>({\n  imports: [...modules],\n  declarations: [...declarations],\n  exports: [...declarations]\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> SharedModule {\n  <span class=\"hljs-keyword\">static</span> forRoot(): ModuleWithProviders {\n    <span class=\"hljs-keyword\">return</span> {\n      ngModule: SharedModule,\n      providers: [...services]\n    };\n  }\n}\n</code></pre>\n<p>Note that the actual module definition <strong>does not</strong> contain any providers.</p>\n<p>In our <code>AppModule</code>, we could use this module as follows:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@NgModule</span>({\n  imports: [\n    ...modules,\n    SharedModule.forRoot()\n  ],\n  ...\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> AppModule {}\n</code></pre>\n<p>By calling the static <code>forRoot</code> method on the <code>SharedModule</code> we import the entire module <strong>including</strong> its providers.</p>\n<p>In a feature module we would simply import the <code>SharedModule</code> <strong>without</strong> calling <code>forRoot</code>:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@NgModule</span>({\n  imports: [\n    ...modules,\n    SharedModule\n  ],\n  ...\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> SomeFeature {}\n</code></pre>\n<p>The fact that each component has its own injector that inherits from its parent injector, allows us to ask for services provided on a root level. Therefore, we have access to all components, pipes, etc. provided by the <code>SharedModule</code> without creating multiple instances of its services.</p>\n<h3>Additional Resources</h3>\n<ul>\n<li><a href=\"https://blog.thoughtram.io/angular/2015/05/18/dependency-injection-in-angular-2.html\">Dependency Injection in Angular</a> by Pascal Precht</li>\n<li><a href=\"https://blog.thoughtram.io/angular/2016/09/14/bypassing-providers-in-angular-2.html\">Bypassing Providers in Angular</a> by Pascal Precht</li>\n<li><a href=\"https://blog.angularindepth.com/avoiding-common-confusions-with-modules-in-angular-ada070e6891f\">Avoiding common confusions with modules in Angular</a> by Maxim Koretskyi</li>\n</ul>\n"
    },
    "1pQWxn": {
      "id": "1pQWxn",
      "slug": "put-business-logic-into-services",
      "category": "architecture",
      "title": "put business logic into services",
      "content": "<h3>Problem</h3>\n<p>With Angular we are creating applications using a layered architecture. Every layer in our application should have its own responsibility. This means we have decoupled layers and each with its own concern.\nBusiness logic in our application does not belong in the component layer. The component layer is purely meant to be used for visualization, displaying user interface and handling user input. Therefore, business logic should be extracted into the service layer.</p>\n<h3>Solution</h3>\n<p>In the following example, we are using the <code>HttpClient</code> to fetch data from a backend. This should not be done from the component layer but instead we move the logic into a dedicated service.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@Component</span>({\n  ...\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> SomeComponent <span class=\"hljs-keyword\">implements</span> OnInit {\n  data$;\n\n  <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">private</span> http: HttpClient</span>) {}\n\n  ngOnInit() {\n    <span class=\"hljs-keyword\">this</span>.data$ = <span class=\"hljs-keyword\">this</span>.http.get(<span class=\"hljs-string\">'http://some-api.com/'</span>);\n  }\n}\n</code></pre>\n<p>We can refactor this and move the logic into a <code>PeopleService</code>.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@Component</span>({\n  ...\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> SomeComponent <span class=\"hljs-keyword\">implements</span> OnInit, OnDestroy {\n  data$;\n\n  <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">private</span> peopleService: PeopleService</span>) {}\n\n  ngOnInit() {\n    <span class=\"hljs-keyword\">this</span>.data$ = <span class=\"hljs-keyword\">this</span>.peopleService.getPeople();\n  }\n}\n</code></pre>\n"
    },
    "NEzhm": {
      "id": "NEzhm",
      "slug": "use-descriptive-file-names",
      "category": "architecture",
      "title": "use descriptive file names",
      "content": "<h3>Problem</h3>\n<p>When applications grow over time, it can be quite hard to identify and find certain parts in our application. When we don’t give a descriptive name to our files, this makes it even more difficult to do so.</p>\n<h3>Solution</h3>\n<h4>Separate file names with dots and dashes</h4>\n<p>It is recommended to separate words with dashes and dots to separate the descriptive name from the type. The descriptive name of a file should describe the component’s feature.</p>\n<p>Also, try to use conventional suffix that describe the type of the file, e.g. <code>.component.ts</code>, <code>.directive.ts</code>, <code>.service.ts</code>, <code>.module.ts</code>, <code>.pipe.ts</code>.</p>\n<p>Here are a few examples:</p>\n<ul>\n<li><code>app.component.ts</code></li>\n<li><code>contacts.service.ts</code></li>\n<li><code>product-list.component.ts</code></li>\n</ul>\n<p>Using such naming convention helps to provide a consistent way to find content very quickly and easily. Consistency will save you time and make you and your team more efficient.</p>\n<h4>Use the name and type of the file for your class names</h4>\n<p>If the file you are working on is <code>app.component.ts</code> it is obvious that this must be a component. It also tells us the name of this component, which is <code>app</code>. This means we’d call our class <code>AppComponent</code>:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@Component</span>({ ... })\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> AppComponent { }\n</code></pre>\n<p>Here’s another example of a class defined in <code>product-list.component.ts</code>:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@Component</span>({ ... })\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> ProductListComponent { }\n</code></pre>\n"
    },
    "Z2qKc11": {
      "id": "Z2qKc11",
      "slug": "use-modules-to-define-features",
      "category": "architecture",
      "title": "use modules to define features",
      "author": {
        "name": "Billy Lando",
        "url": "https://github.com/billyjov"
      },
      "content": "<h3>Problem</h3>\n<p>As an app scales, the root module starts growing and declaring a vast number of components increases the start time as well as affects the application’s performance. Additionally, the more components we add to the root module, the harder it gets to understand the application’s structure, and therefore making it hard to maintain.</p>\n<h3>Solution</h3>\n<p>Using an <code>NgModule</code> to define features in Angular allows lazy loading, isolation and portability of this features. The purpose of feature modules is to organize relevant code into cohesive blocks. This helps to apply clear boundaries between features or application domains.</p>\n<p>Another benefit of <code>NgModules</code> is that they allow us to lazy load each feature module in order to boost the performance of our app, especially time to <strong>first meaningful paint</strong> (FMP). Furthermore, feature encapsulation using modules allow us to replace each module without (or with small changes) affecting other modules.</p>\n<p>Here’s an example:</p>\n<pre class=\"hljs\"><code>\n<span class=\"hljs-meta\">@Component</span>({ ... })\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> AddPeopleComponent <span class=\"hljs-keyword\">implements</span> OnInit {\n  ...\n}\n\n<span class=\"hljs-meta\">@Component</span>({...})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> ListPeopleComponent <span class=\"hljs-keyword\">implements</span> OnInit {\n  ...\n}\n\n<span class=\"hljs-meta\">@NgModule</span>({\n  ...\n  imports: []\n  declarations: [\n    AddPeopleComponent,\n    ListPeopleComponent\n    <span class=\"hljs-comment\">// other components</span>\n  ],\n  ...\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> AppModule {}\n</code></pre>\n<p>The above can be refactored to:</p>\n<pre class=\"hljs\"><code>\n<span class=\"hljs-meta\">@Component</span>({ ... })\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> AddPeopleComponent <span class=\"hljs-keyword\">implements</span> OnInit {\n  ...\n}\n\n<span class=\"hljs-meta\">@Component</span>({ ... })\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> ListPeopleComponent <span class=\"hljs-keyword\">implements</span> OnInit {\n  ...\n}\n\n<span class=\"hljs-comment\">// introduce a new feature module</span>\n<span class=\"hljs-meta\">@NgModule</span>({\n  imports: [\n    CommonModule\n  ]\n  declarations: [\n    AddPeopleComponent,\n    ListPeopleComponent\n  ]\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> PeopleModule {}\n\n\n<span class=\"hljs-meta\">@NgModule</span>({\n  ...\n  imports: [\n    <span class=\"hljs-comment\">// import our new feature module</span>\n    PeopleModule\n  ]\n  declarations: [\n    <span class=\"hljs-comment\">// other components</span>\n  ],\n  ...\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> AppModule {}\n</code></pre>\n<p>Alternatively, we can use lazy loading as described <a href=\"/default/checklist/router/Z165VzV\">here</a>.</p>\n<h4>What if something needs to be reused elsewhere?</h4>\n<p>In this case, using a <code>SharedModule</code> helps to organize reusable parts into its own module. We can put commonly used directives, pipes, and components into one module and then import the <code>SharedModule</code> wherever we need it in other parts of our application.\nBut we aware of possibly multiple service instances. For more information check <a href=\"/default/checklist/architecture/Z1ohpIo\">this item</a>.</p>\n<h3>Resources</h3>\n<ul>\n<li><a href=\"https://blog.angularindepth.com/avoiding-common-confusions-with-modules-in-angular-ada070e6891f\">Avoiding common confusions with modules in Angular</a> by Max Koretskyi</li>\n<li><a href=\"https://www.youtube.com/watch?v=ntJ-P-Cvo7o\">Module vs Module</a> by Deborah Kurata</li>\n<li><a href=\"https://angular.io/guide/feature-modules\">Angular documentation for Feature Modules</a></li>\n</ul>\n"
    },
    "Z1eHhoR": {
      "id": "Z1eHhoR",
      "slug": "use-smart-and-dumb-components",
      "category": "architecture",
      "title": "use smart and dumb components",
      "content": "<h3>Problem</h3>\n<p>Every major frontend framework is moving towards a component-based architecture. Components are a combination of HTML, JavaScript and CSS. If we start injecting services in every component, tightly couple them by letting them fetch their own data, we are not leveraging the power of a component-based architecture.</p>\n<h3>Solution</h3>\n<p>The most advocated way to lay out your components is to use smart and dumb components (there is a variety of other names for this principle but the general idea is the same).</p>\n<h4>Component Types</h4>\n<h5>Dumb Component</h5>\n<ul>\n<li>Receives data through <code>@Input</code>s and communicates only with it’s direct parent through <code>@Output</code>s.</li>\n<li>Dumb components should not receive <code>Observables</code> as inputs.</li>\n<li>They do not know about the rest of the application and hence does not know where they are being used.</li>\n<li>Can contain business logic, but only logic that belongs to the scope of this component. For example, a pagination component can contain logic to calculate the number of ‘boxes’ to show. It does not know what happens when a user clicks a page number. In that case, it would emit a custom event to notify its parent that something has happened. The parent component then decides what to do and takes action.</li>\n<li>They can use other dumb components as children.</li>\n<li>They can inject services that are related to the view layer of your application (think <code>TranslateService</code>, <code>Router</code>, …) but never services that handle business logic such as fetching data.</li>\n</ul>\n<h5>Smart Component</h5>\n<ul>\n<li>Smart components are application-level components.</li>\n<li>They know how to fetch data and persist changes.</li>\n<li>They pass data down to dumb components as much as possible and mostly only contains business logic to fetch data.</li>\n<li>They compose several other dumb components in its template.</li>\n<li>They listen for events emitted by dumb components and perform the required action.</li>\n</ul>\n<h4>Benefits</h4>\n<ul>\n<li>Dumb components are completely reusable since they have a defined API and are independent of any business logic.</li>\n<li>Dumb components are easy to test as they are completely isolated.</li>\n<li>The entire architecture of your components becomes easier to reason about. If there is problem with business logic or if the data is not correctly fetched, you know that you need to start searching in your smart components since this is their only responsibility.</li>\n</ul>\n<h3>Resources</h3>\n<ul>\n<li><a href=\"https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0\">Presentational and container components</a> by Dan Abramov</li>\n<li><a href=\"https://blog.angular-university.io/angular-2-smart-components-vs-presentation-components-whats-the-difference-when-to-use-each-and-why/\">Smart components vs presentational components</a> by Angular University</li>\n<li><a href=\"https://blog.strongbrew.io/the-smart-vs-dumb-components-quiz/\">The smart vs dumb component quiz</a> by Kwinten Pisman</li>\n</ul>\n"
    },
    "2eREkv": {
      "id": "2eREkv",
      "slug": "clean-up-resource-in-ng-on-destroy",
      "category": "components",
      "title": "release resources in ngOnDestroy",
      "content": "<h4>Problem</h4>\n<p>When creating Angular components, we need to use resources to get user input, fetch data from the backend, create animations, etc. The way we do this varies. We could use Observables, browser APIs, event listeners or other means. When using resources, we also need to release those resources when they are no longer required. If we do <strong>not</strong> do this, we might introduce memory leaks which will make our application crash and introduce other unwanted behavior.</p>\n<h4>Solution</h4>\n<p>For every component and directive, Angular offers lifecycle hooks that provide visibility into key life moments of a component, such as creation, rendering, or when data-bound properties have changed.</p>\n<p>In order to release our resources, we can hook into the <code>ngOnDestroy</code> lifecyle of a component. This hook is called <strong>before</strong> a component is destroyed and removed from the DOM.</p>\n<p>In the following example, we set up a function to be executed every 5000ms using the <code>setInterval</code> API. Inside <code>ngOnDestroy</code>, we clear the interval and release the resource.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@Component</span>({\n  ...\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> SomeComponent <span class=\"hljs-keyword\">implements</span> OnInit, OnDestroy {\n  intervalId;\n\n  ngOnInit() {\n    <span class=\"hljs-keyword\">this</span>.intervalId = setInterval(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {...}, <span class=\"hljs-number\">5000</span>);\n  }\n\n  ngOnDestroy() {\n    clearInterval(<span class=\"hljs-keyword\">this</span>.intervalId);\n  }\n}\n</code></pre>\n"
    },
    "2rF4Hq": {
      "id": "2rF4Hq",
      "slug": "dont-use-property-bindings-to-pass-static-strings",
      "category": "components",
      "title": "don't use property bindings to pass static strings to native attributes",
      "content": "<h3>Problem</h3>\n<p>Property bindings in Angular allows us to bind to properties. During change detection, when a component is checked, all of the bindings for that component are being checked to see if the view needs to be updated. This means that the more bindings we create, the slower the CD cycle will be, as more bindings need to be checked.</p>\n<p>If we have static strings that we want to pass to a native attribute (such as <code>id</code> and <code>title</code>) of an HTML element, it’s not necessary to use a property binding as the value will never change. This seems to be a trivial thing to talk about, but it can have a great impact the performance of our application.</p>\n<h3>Solution</h3>\n<p>Only use a property binding for dynamic values. Use attributes to pass static string values to native attributes.</p>\n<p>In the following example, we bind a static string to the <code>id</code> property of an input field. This doesn’t make much sense because this string is passed statically and will never change. So, why use a property binding for this?</p>\n<pre class=\"hljs\"><code>&lt;input [id]=<span class=\"hljs-string\">\"'exampleId'\"</span> /&gt;\n</code></pre>\n<p>In order to fix this, we can remove the property binding and use the native <code>id</code> attribute instead.</p>\n<pre class=\"hljs\"><code>&lt;input id=<span class=\"hljs-string\">\"exampleId\"</span> /&gt;\n</code></pre>\n"
    },
    "ZXcqct": {
      "id": "ZXcqct",
      "slug": "minimize-logic-in-templates",
      "category": "components",
      "title": "minimize logic in templates",
      "content": "<h3>Problem</h3>\n<p>When we put too much logic in our templates, we are making our applications more difficult to test. The fastest way to write and execute tests is to use simple unit tests. Of course we could also test a component’s template with a unit test but that increases the complexity and introduces some challenges we have to deal with.</p>\n<p>In addition, too much logic inside the template makes them less readable. We cannot take a quick glance at the template and quickly understand what’s going on.</p>\n<h3>Solution</h3>\n<p>Try to avoid putting too much logic in your templates.</p>\n<p>For example here, we have have an <code>*ngIf</code> that has too much logic.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@Component</span>({\n  template: <span class=\"hljs-string\">`&lt;div *ngIf=\"users &amp;&amp; users.length &gt; 1 &amp;&amp; visible\"&gt;content to show&lt;/div&gt;`</span>\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> SomeComponent {\n  users: User[];\n  visible: <span class=\"hljs-built_in\">boolean</span>;\n}\n</code></pre>\n<p>We can refactor this by extracting the logic into the component’s class. This will make the template more readable and the logic easier to test.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@Component</span>({\n  template: <span class=\"hljs-string\">`&lt;div *ngIf=\"usersExistsAndVisible()\"&gt;content to show&lt;/div&gt;`</span>\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> SomeComponent {\n  users: User[];\n  visible: <span class=\"hljs-built_in\">boolean</span>;\n\n  usersExistsAndVisible() {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.users &amp;&amp; <span class=\"hljs-keyword\">this</span>.users.length &gt; <span class=\"hljs-number\">1</span> &amp;&amp; <span class=\"hljs-keyword\">this</span>.visible;\n  }\n}\n</code></pre>\n"
    },
    "ZXTLWo": {
      "id": "ZXTLWo",
      "slug": "ng-oninit-vs-constructor",
      "category": "components",
      "title": "put init logic in the ngOnInit lifecycle hook",
      "content": "<h3>Problem</h3>\n<p>The constructor is a function of a class that is being called during the construction of an instance of that component. Angular leverages the constructor to provide us with the dependencies we requested. It doesn’t mean however, that Angular is fully finished with the creation of this component. The <code>@Input</code> bindings for example will not be initialised yet. Angular will call the <code>ngOnInit</code> lifecycle hook when it’s ready.</p>\n<p>If we put logic inside the constructor, especially data-fetching logic, we are doing things before Angular has finished creating the component. It also has an impact on how we test our code. In a unit test, we will probably instantiate an instance of a component in a <code>beforeEach</code> block. If this already initialises some logic or fetches data, it will impact every other test and make it harder to test this particular logic.</p>\n<h3>Solution</h3>\n<p>To fix this, we need to move all initialization logic that needs to be tested and that uses <code>@Input</code> bindings to the <code>ngOnInit</code> lifecycle hook.</p>\n<p>The constructor should only be used for injecting dependencies.</p>\n<p>Here’s a concrete example.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@Component</span>({\n  template: <span class=\"hljs-string\">`...`</span>\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> SomeComponent {\n  users$: Observable&lt;User&gt;;\n\n  <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">private</span> usersService: UsersService</span>) {\n    <span class=\"hljs-keyword\">this</span>.users$ = <span class=\"hljs-keyword\">this</span>.usersService.getUsers();\n  }\n}\n</code></pre>\n<p>We refactor this by moving the code from the constructor into the <code>ngOnInit</code> lifecycle hook.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@Component</span>({\n  template: <span class=\"hljs-string\">`...`</span>\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> SomeComponent <span class=\"hljs-keyword\">implements</span> OnInit {\n  users$: Observable&lt;User&gt;;\n  <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">private</span> usersService: UsersService</span>) {}\n\n  ngOnInit() {\n    <span class=\"hljs-keyword\">this</span>.users$ = <span class=\"hljs-keyword\">this</span>.usersService.getUsers();\n  }\n}\n</code></pre>\n<h3>Resources</h3>\n<ul>\n<li><a href=\"https://blog.angularindepth.com/the-essential-difference-between-constructor-and-ngoninit-in-angular-c9930c209a42\">The essential difference between Constructor and ngOnInit in Angular</a> by Maxim Koretskyi</li>\n</ul>\n"
    },
    "Z1eEvQQ": {
      "id": "Z1eEvQQ",
      "slug": "only-manipulate-the-dom-via-the-renderer",
      "category": "components",
      "title": "only manipulate the DOM via the Renderer",
      "author": {
        "name": "Billy Lando",
        "url": "https://github.com/billyjov"
      },
      "content": "<h3>Problem</h3>\n<p>According to the Angular documentation, relying on direct DOM access creates tight coupling between your application and rendering layers which will make it impossible to separate the two and deploy your application into a web worker.</p>\n<p>Consequently, using jQuery , <code>document</code> object, or <code>ElementRef.nativeElement</code> is not recommended as it’s not available on other platforms such as server (for server-side rendering) or web worker.</p>\n<p>In addition, permitting direct access to the DOM can make your application more vulnerable to <strong>XSS</strong> attacks.</p>\n<h3>Solution</h3>\n<p>Always try to prefer the <code>Renderer2</code> for DOM manipulations. It provides an API that can safely be used even when direct access to native elements is not supported.</p>\n<ul>\n<li><strong>Bad practice</strong></li>\n</ul>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@Component</span>({\n  ...\n  template: <span class=\"hljs-string\">`\n    &lt;textarea&gt;&lt;/textarea&gt;\n    &lt;my-child-component&gt;&lt;/my-child-component&gt;\n  `</span>\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> SomeComponent <span class=\"hljs-keyword\">implements</span> OnInit {\n\n  <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">private</span> elementRef: ElementRef</span>) {}\n    \n  ngOnInit() {\n    <span class=\"hljs-keyword\">this</span>.elementRef.nativeElement.style.backgroundColor = <span class=\"hljs-string\">'#fff'</span>;\n    <span class=\"hljs-keyword\">this</span>.elementRef.nativeElement.style.display = <span class=\"hljs-string\">'inline'</span>;\n    <span class=\"hljs-keyword\">const</span> textareaElement = <span class=\"hljs-built_in\">document</span>.querySelector(<span class=\"hljs-string\">'textarea'</span>);\n    <span class=\"hljs-keyword\">const</span> myChildComponent = $(<span class=\"hljs-string\">'my-child-component'</span>);\n  }\n}\n</code></pre>\n<p>We can refactor this by using a combination of <code>ElementRef</code> and <code>Renderer2</code>.</p>\n<ul>\n<li><strong>Good practice</strong></li>\n</ul>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> { MyChildComponent } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./my-child.component'</span>;\n\n<span class=\"hljs-meta\">@Component</span>({\n  ...\n  template: <span class=\"hljs-string\">`\n    &lt;textarea #textareaRef&gt;&lt;/textarea&gt;\n    &lt;my-child-component&gt;&lt;/my-child-component&gt;\n  `</span>\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> SomeComponent <span class=\"hljs-keyword\">implements</span> OnInit {\n\n  <span class=\"hljs-meta\">@ViewChild</span>(<span class=\"hljs-string\">'textareaRef'</span>) myTextAreaRef: ElementRef;\n  <span class=\"hljs-meta\">@ViewChild</span>(MyChildComponent) myChildComponentRef: MyChildComponent;\n\n  <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">private</span> elementRef: ElementRef, <span class=\"hljs-keyword\">private</span> renderer: Renderer2</span>) {}\n    \n  ngOnInit() {\n    <span class=\"hljs-keyword\">this</span>.renderer.setStyle(<span class=\"hljs-keyword\">this</span>.elementRef.nativeElement, <span class=\"hljs-string\">'backgroundColor'</span>, <span class=\"hljs-string\">'#fff'</span>);\n    <span class=\"hljs-keyword\">this</span>.renderer.setStyle(<span class=\"hljs-keyword\">this</span>.elementRef.nativeElement, <span class=\"hljs-string\">'display'</span>, <span class=\"hljs-string\">'inline'</span>);\n    <span class=\"hljs-keyword\">const</span> textareaElement = <span class=\"hljs-keyword\">this</span>.myTextAreaRef.nativeElement;\n    <span class=\"hljs-keyword\">const</span> myComponent = <span class=\"hljs-keyword\">this</span>.myChildComponent;\n  }\n}\n</code></pre>\n<h3>Resources</h3>\n<ul>\n<li><a href=\"https://angular.io/api/core/ElementRef#description\">Angular Documentation for ElementRef</a></li>\n<li><a href=\"https://blog.angularindepth.com/exploring-angular-dom-abstractions-80b3ebcfc02\">Exploring Angular DOM manipulation techniques using ViewContainerRef</a> by Max Koretskyi</li>\n</ul>\n"
    },
    "1KaHiT": {
      "id": "1KaHiT",
      "slug": "use-latest-version-of-everything",
      "category": "general",
      "title": "use latest version of everything",
      "author": {
        "name": "Billy Lando",
        "url": "https://github.com/billyjov"
      },
      "content": "<h3>Problem</h3>\n<p>The Angular team and community are continually improving the ecosystem to make it easier to build applications. Both the performance and the compiler (e.g Ivy Renderer) are constantly being improved for better web applications.</p>\n<p>Angular uses semantic versioning (semver) which means they use a regular schedule of releases. This includes a major release every six month, 1-3 minor releases for each major release, and a patch release almost every week. It’s important to keep up with major releases as they contain significant new features. The longer we wait to update our application, the more expensive will be a future update. Be aware, that major releases may contain breaking changes.</p>\n<p>In addition, when API’s get deprecated they remain present in the next two major releases until they are removed. Again, if we wait to long, it’s likely that the update requires much more work. You can read more about deprecations in the <a href=\"https://github.com/angular/angular/blob/master/CHANGELOG.md\">changelog</a>.</p>\n<h3>Solution</h3>\n<p>You can follow this steps using Angular CLI:</p>\n<ul>\n<li><strong>Step 1:</strong> Create a new feature branch</li>\n<li><strong>Step 2:</strong> Run <code>ng update @angular/core @angular/cli</code> inside your project directory</li>\n<li><strong>Step 3:</strong> Run <code>ng serve</code>, <code>ng test</code>, <code>ng build --prod</code> and make sure your app works as expected</li>\n<li><strong>Step 4:</strong> Fix update deprecations, issues, styling issues in case of Angular Material and run the previous step again</li>\n<li><strong>Step 5:</strong> merge or rebase your changes on top of the main branch</li>\n</ul>\n<p>For more information, check out the <a href=\"https://update.angular.io/\">official update guide</a> on how to update from different versions.</p>\n<h3>Resources</h3>\n<ul>\n<li><a href=\"https://angular.io/guide/updating\">Keeping your Angular Projects Up-to-Date</a></li>\n<li><a href=\"https://itnext.io/dont-be-afraid-and-just-ng-update-1ad096147640\">Don’t be afraid and just <code>ng update</code>!</a> by Bram Borggreve</li>\n</ul>\n"
    },
    "2oN0jv": {
      "id": "2oN0jv",
      "slug": "dont-reimport-httpclientmodule",
      "category": "http",
      "title": "don't re-import HttpClientModule",
      "content": "<h3>Problem</h3>\n<p><code>HttpClientModule</code> is responsible for providing us with HTTP related functionality. One such functionality is the ability to specify interceptors that inspect and transform HTTP requests from your application to the server.\nWhen re-importing <code>HttpClientModule</code> in a lazy-loaded module or a dependency of a lazy-loaded module, existing HTTP interceptors will be overridden for that module.</p>\n<h3>Solution</h3>\n<p>Import <code>HttpClientModule</code> only once in the root module.</p>\n<h3>Resources</h3>\n<ul>\n<li><a href=\"https://github.com/angular/angular/issues/20575\">HTTP_INTERCEPTORS are reset when re-importing HttpClientModule</a></li>\n</ul>\n"
    },
    "Z2exNXo": {
      "id": "Z2exNXo",
      "slug": "action-hygiene",
      "category": "ngrx",
      "title": "capture events with actions, not commands",
      "content": "<h3>Problem</h3>\n<p>When using NgRx, we are constantly dispatching actions to the store. These can be dispatched from different places such as components and effects. It can become really hard to figure out where all these actions originated from, why they were sent and how they are impacting the state.</p>\n<h3>Solution</h3>\n<p>By changing the way we name our actions, we can more easily see where actions are being dispatched from. It allows us, by just looking at the action history, what the user was doing and the order he was doing it in. So instead of having something like this as action log:</p>\n<ul>\n<li>[Users] Add User</li>\n<li>[Users] Remove User</li>\n<li>[Users] Update User</li>\n</ul>\n<p>We can have something like:</p>\n<ul>\n<li>[Users Overview Page] Add User</li>\n<li>[Users Overview Page] Remove User</li>\n<li>[Users Detail Page] Update User</li>\n</ul>\n<p>This also implies that actions should not be reused. This might seem like an overkill to create a second action that will have the same result. But we have to keep in mind that at some point in time, we might need to update this code later on. This explicitness will help us in the future.</p>\n<p>This is considered good <em>action hygiene</em>. The format for action names should be <code>[${source}] ${event}</code>.</p>\n<h3>Resources</h3>\n<ul>\n<li><a href=\"https://www.youtube.com/watch?v=JmnsEvoy-gY\">Good action hygiene</a> by Mike Ryan</li>\n</ul>\n"
    },
    "iglD3": {
      "id": "iglD3",
      "slug": "actions-are-defined-as-classes",
      "category": "ngrx",
      "title": "define actions as classes",
      "content": "<h3>Problem</h3>\n<p>When we send an action to the store, we need to send an object that has a type property and optional metadata (often added as a payload property). We could recreate an object every time we want to send that but we would violate the DRY principle.</p>\n<p>One of the promises in NgRx is that it provides extreme type safety. This is something that cannot be achieved with plain objects.</p>\n<h3>Solution</h3>\n<p>We want to define our actions as classes. When we use classes to define our actions, we can define them once in a separate file and reuse them everywhere.</p>\n<p>Here’s an example on how to define an action.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> { Action } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@ngrx/store'</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">enum</span> AppActionTypes {\n  APP_PAGE_LOAD_USERS = <span class=\"hljs-string\">'[App Page] Load Users'</span>\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> AppPageLoadUsers <span class=\"hljs-keyword\">implements</span> Action {\n  readonly <span class=\"hljs-keyword\">type</span> = AppActionTypes.APP_PAGE_LOAD_USERS;\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">type</span> AppActions = AppPageLoadUsers;\n</code></pre>\n<p>Now, we can use the <code>AppPageLoadUsers</code> class to send this action to the store which is then passed to our reducers.</p>\n<p><strong>Note:</strong> Because of the way the action is being defined, using features like string literals and union types, we can leverage discriminated unions in our reducers to have extreme type safety when it comes to typing the action’s payload. See the additional resources for more info.</p>\n<h3>Resources</h3>\n<ul>\n<li><a href=\"https://blog.strongbrew.io/type-safe-actions-in-reducers/\">Type safe actions in reducers</a> by Kwinten Pisman</li>\n</ul>\n"
    },
    "ZPhLz2": {
      "id": "ZPhLz2",
      "slug": "do-not-put-everything-in-the-store",
      "category": "ngrx",
      "title": "don't put everything in the store",
      "content": "<h3>Problem</h3>\n<p><code>@ngrx/store</code> (or Redux in general) provides us with a lot of great features and can be used in a lot of use cases. But sometimes this pattern can be an overkill. Implementing it means we get the downside of using Redux (a lot of extra code and complexity) without benefiting of the upsides (predictable state container and unidirectional data flow).</p>\n<h3>Solution</h3>\n<p>The NgRx core team has come up with a principle called <strong>SHARI</strong>, that can be used as a rule of thumb on data that needs to be added to the store.</p>\n<ul>\n<li>Shared: State that is shared between many components and services</li>\n<li>Hydrated: State that needs to be persisted and hydrated across page reloads</li>\n<li>Available: State that needs to be available when re-entering routes</li>\n<li>Retrieved: State that needs to be retrieved with a side effect, e.g. an HTTP request</li>\n<li>Impacted: State that is impacted by other components</li>\n</ul>\n<p>Try not to over-engineer your state management layer. Data is often fetched via XHR requests or is being sent over a WebSocket, and therefore is handled on the server side. Always ask yourself <strong>when</strong> and <strong>why</strong> to put some data in a client side store and keep alternatives in mind. For example, use routes to reflect applied filters on a list or use a <code>BehaviorSubject</code> in a service if you need to store some simple data, such as settings. Mike Ryan gave a very good talk on this topic: <a href=\"https://youtu.be/omnwu_etHTY\">You might not need NgRx</a></p>\n<h3>Resources</h3>\n<ul>\n<li><a href=\"https://www.youtube.com/watch?v=t3jx0EC-Y3c\">Reducing the Boilerplate with NgRx</a> by Mike Ryan and Brandon Roberts</li>\n<li><a href=\"https://blog.strongbrew.io/do-we-really-need-redux/\">Do we really need @ngrx/store</a> by Brecht Billiet</li>\n<li><a href=\"https://juristr.com/blog/2018/10/simple-state-management-with-scan/\">Simple State Management with RxJS’s scan operator</a> by Juri Strumpflohner</li>\n</ul>\n"
    },
    "1kimRN": {
      "id": "1kimRN",
      "slug": "dont-store-state-that-can-be-derived",
      "category": "ngrx",
      "title": "don't store state that can be derived",
      "content": "<h3>Problem</h3>\n<p>We can use <code>@ngrx/store</code> to store data. When we store duplicate data, we are making our reducer logic way more difficult. Take a look at the following type definition for a potential state object:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">interface</span> ApplicationState {\n  users: <span class=\"hljs-built_in\">Array</span>&lt;User&gt;;\n  selectedUserId: <span class=\"hljs-built_in\">number</span>;\n  selectedUser: User;\n}\n</code></pre>\n<p>In this scenario, we are both storing the id of the <code>selectedUser</code> and the object of the <code>selectedUser</code>. This poses a lot of problems. First of all, when we change the selected user, we need to remember to update both references. But even worse, what if we update the user that is currently selected. Then we need to update both the reference in the <code>users</code> array and the <code>selectedUser</code>. This is easily overlooked and makes the implementation much more difficult and verbose.</p>\n<h3>Solution</h3>\n<p>To fix this, we <strong>shouldn’t store state that can be derived</strong>. If we store the <code>users</code> and the <code>selectedUserId</code>, we can easily derive which user is selected. This is logic that we can put in a selector or most probably in a composed selector. As a solution, we can define the state object as follows:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">interface</span> ApplicationState {\n  users: <span class=\"hljs-built_in\">Array</span>&lt;User&gt;;\n  selectedUserId: <span class=\"hljs-built_in\">number</span>;\n}\n</code></pre>\n<p>Now, when we update a user, we only need to update the reference in the <code>users</code> array.</p>\n"
    },
    "ZlteSK": {
      "id": "ZlteSK",
      "slug": "reducers-are-pure-functions",
      "category": "ngrx",
      "title": "reducers are pure functions",
      "content": "<h3>Problem</h3>\n<p>Reducers are responsible for updating the state in our application based on actions. It is extremely important that these are pure making them deterministic, so that every action, given the same input, will always have the same result. If they are not pure, we can no longer trust them to manage our state.</p>\n<h3>Solution</h3>\n<p>By writing our reducers as pure functions, we are 100% sure that the reducer is deterministic and can be used to manage our state. A pure function has the following properties:</p>\n<ul>\n<li>it does not depend on external state</li>\n<li>it does not produce any side-effects</li>\n<li>it does not mutate any of its inputs</li>\n<li>if you call it over and over again, with the same arguments, you always get back the same results</li>\n</ul>\n<p>These properties are exactly what we need for our reducers to be deterministic and to comply with the key concepts of Redux.</p>\n<p>In addition, pure functions are very easy to test.</p>\n<p>Example of an <strong>impure</strong> function:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> state = <span class=\"hljs-number\">1</span>;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">impureFunction</span>(<span class=\"hljs-params\">value: <span class=\"hljs-built_in\">number</span></span>) </span>{\n  <span class=\"hljs-keyword\">return</span> value + state;\n}\n\n<span class=\"hljs-comment\">// Returns 2</span>\nimpureFunction(<span class=\"hljs-number\">1</span>);\n</code></pre>\n<p>The <code>impureFunction</code> relies on external state making it non-deterministic. We have no control of the state defined outside of the function as it is visible to many other functions.</p>\n<p>Instead, we can make this function <strong>pure</strong> by passing in the data it needs:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> state = <span class=\"hljs-number\">1</span>;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">pureFunction</span>(<span class=\"hljs-params\">value: <span class=\"hljs-built_in\">number</span>, otherValue: <span class=\"hljs-built_in\">number</span></span>) </span>{\n  <span class=\"hljs-keyword\">return</span> value + otherValue;\n}\n\n<span class=\"hljs-comment\">// Returns 2</span>\npureFunction(<span class=\"hljs-number\">1</span>, state);\n</code></pre>\n<p>Now, <code>pureFunction</code> only relies on its parameters, does not mutate its arguments and has no side-effects.</p>\n<p>The same is true for reducers. They have the following signature <code>(state, action) =&gt; state</code>. They do not rely on external state and shouldn’t update its inputs.</p>\n"
    },
    "1t4mCT": {
      "id": "1t4mCT",
      "slug": "use-entity-pattern",
      "category": "ngrx",
      "title": "use the entity pattern for large collections",
      "content": "<h3>Problem</h3>\n<p>In our applications, we use a lot of arrays to store our data. When we fetch a list of users and we want to show them in the view, we can loop over them really easily using the <code>*ngFor</code> directive. We can put that data in our store so that we, for example, don’t have to fetch it again later, or if the list is impacted by other components.</p>\n<p>But arrays are not the most performant solution when we want to update, delete, or get a single element out of the list. All these operations have a linear time complexity of O(n). For large collections, this can have a huge impact on the performance.</p>\n<h3>Solution</h3>\n<p>To make the CRUD operations more efficient we can adopt the entity pattern. This means that we will no longer store the data as an array but transform it to an object where the key is the unique identifier of the element and the value is the actual element. This is also called state normalization.</p>\n<p>Here’s an example.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> contacts = [\n  { id: <span class=\"hljs-number\">1</span>, name: <span class=\"hljs-string\">'Dominic Elm'</span> },\n  { id: <span class=\"hljs-number\">2</span>, name: <span class=\"hljs-string\">'Kwinten Pisman'</span> }\n];\n</code></pre>\n<p>We can normalize this into the following:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> entities = {\n  <span class=\"hljs-number\">1</span>: { id: <span class=\"hljs-number\">1</span>, name: <span class=\"hljs-string\">'Dominic Elm'</span> },\n  <span class=\"hljs-number\">2</span>: { id: <span class=\"hljs-number\">2</span>, name: <span class=\"hljs-string\">'Kwinten Pisman'</span> }\n};\n</code></pre>\n<p>Now, finding, deleting, or updating an element all have a complexity of O(1).</p>\n<p><strong>Note:</strong> As this is a common pattern in NgRx, there is a separate package that will help us to implement the entity pattern called <code>@ngrx/entity</code>.</p>\n<h3>Resources</h3>\n<ul>\n<li><a href=\"https://github.com/ngrx/platform/tree/master/docs/entity\">@ngrx/entity</a></li>\n</ul>\n"
    },
    "Myhw4": {
      "id": "Myhw4",
      "slug": "use-selectors",
      "category": "ngrx",
      "title": "use selectors to select data from the store",
      "content": "<h3>Problem</h3>\n<p>When we want to fetch data from the store, we can use queries to get the data out. These queries are functions that have the following signature <code>(state: T) =&gt; K</code>.</p>\n<p>While retrieving state from the store, we can execute some pretty complex and potentially inefficient or blocking logic. Every time the state changes, this logic will be re-executed.</p>\n<p>Also, the plain queries we define cannot be used to compose new ones. This means that we have to define the same queries in multiple locations violating the DRY principle.</p>\n<h3>Solution</h3>\n<p><code>@ngrx/store</code> provides us with the concept of selectors. A selector helps us to build up queries that have a type signature of <code>(state: T): K</code>. The great benefit of these selectors is that they are composable.</p>\n<p><code>@ngrx/store</code> exposes a <code>createSelector</code> function that accepts other selectors to create new ones based on these. This means that we only have to define every selector just once and reuse them in multiple places.</p>\n<p>Let’s look at a simple example:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// Plain Selector</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> selectFeature = <span class=\"hljs-function\">(<span class=\"hljs-params\">state: AppState</span>) =&gt;</span> state.feature;\n\n<span class=\"hljs-comment\">// Composed Selector</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> selectFeatureCount = createSelector(\n  selectFeature,\n  <span class=\"hljs-function\">(<span class=\"hljs-params\">state: FeatureState</span>) =&gt;</span> state.counter\n);\n</code></pre>\n<p>Another benefit of composed selectors is that they use an optimization technique called memoization. This means that the selector logic will <strong>not</strong> be re-executed if the source selectors did not update. As a result, the complex logic we might execute to get data from the store is only executed when it is actually needed.</p>\n<h3>Resources</h3>\n<ul>\n<li><a href=\"https://github.com/ngrx/platform/blob/master/docs/store/selectors.md\">Selectors in Ngrx</a></li>\n<li><a href=\"https://blog.angularindepth.com/ngrx-parameterized-selector-e3f610529f8\">NgRx: Parameterized selectors</a> by Tim Deschryver</li>\n<li><a href=\"https://en.wikipedia.org/wiki/Memoization\">Memoization</a></li>\n</ul>\n"
    },
    "ZfxFUd": {
      "id": "ZfxFUd",
      "slug": "track-by-option-on-ng-for",
      "category": "performance",
      "title": "use trackBy option on *ngFor",
      "source": "https://github.com/mgechev/angular-performance-checklist#use-trackby-option-for-ngfor-directive",
      "author": {
        "name": "Minko Gechev",
        "url": "https://twitter.com/mgechev"
      },
      "content": "<h3>Problem</h3>\n<p>The <code>*ngFor</code> directive is used for rendering a collection. By default <code>*ngFor</code> identifies object uniqueness by reference.</p>\n<p>Which means when developer breaks reference to object during updating item’s content Angular treats it as removal of the old object and addition of the new object. This effects in destroying old DOM node in the list and adding new DOM node on its place.</p>\n<h3>Solution</h3>\n<p>We can provide a hint for angular how to identify object uniqueness: custom tracking function as the <code>trackBy</code> option for the <code>*ngFor</code> directive. Tracking function takes two arguments: index and item. Angular uses the value returned from tracking function to track items identity. It is very common to use ID of the particular record as the unique key.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@Component</span>({\n  selector: <span class=\"hljs-string\">'yt-feed'</span>,\n  template: <span class=\"hljs-string\">`\n    &lt;h1&gt;Your video feed&lt;/h1&gt;\n    &lt;yt-player *ngFor=\"let video of feed; trackBy: trackById\" [video]=\"video\"&gt;&lt;/yt-player&gt;\n  `</span>\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> YtFeedComponent {\n  feed = [\n    {\n      id: <span class=\"hljs-number\">3849</span>, <span class=\"hljs-comment\">// note \"id\" field, we refer to it in \"trackById\" function</span>\n      title: <span class=\"hljs-string\">'Angular in 60 minutes'</span>,\n      url: <span class=\"hljs-string\">'http://youtube.com/ng2-in-60-min'</span>,\n      likes: <span class=\"hljs-string\">'29345'</span>\n    }\n    <span class=\"hljs-comment\">// ...</span>\n  ];\n\n  trackById(index, item) {\n    <span class=\"hljs-keyword\">return</span> item.id;\n  }\n}\n</code></pre>\n<h3>Resources</h3>\n<ul>\n<li><a href=\"https://angular.io/docs/ts/latest/api/common/index/NgFor-directive.html\">“NgFor directive”</a> - Official documentation for <code>*ngFor</code></li>\n<li><a href=\"https://netbasal.com/angular-2-improve-performance-with-trackby-cc147b5104e5\">“Angular  —  Improve performance with trackBy”</a> - By Netanel Basal</li>\n</ul>\n"
    },
    "CjbpO": {
      "id": "CjbpO",
      "slug": "use-aot-compilation",
      "category": "performance",
      "title": "use AOT compilation for prod builds",
      "source": "https://github.com/mgechev/angular-performance-checklist",
      "author": {
        "name": "Minko Gechev",
        "url": "https://twitter.com/mgechev"
      },
      "content": "<h3>Problem</h3>\n<p>The biggest part of the code that we ship to the browser when we use Angular is the compiler. The compiler is needed to transform our HTML-like templates to Javascript. This is doesn’t only has a negative impact on the bundle size but also on the performance as this process is computationally expensive.</p>\n<h3>Solution</h3>\n<p>We can avoid shipping the compiler by performing the compile step as part of the build step. We can achieve this by using AOT.</p>\n<p>AoT can be helpful not only for achieving more efficient bundling by performing tree-shaking, but also for improving the runtime performance of our applications. The alternative of AoT is Just-in-Time compilation (JiT) which is performed runtime, therefore we can reduce the amount of computations required for rendering of our application by performing the compilation as part of our build process.</p>\n<h3>Tooling</h3>\n<ul>\n<li><a href=\"https://github.com/angular/angular/tree/master/packages/compiler-cli\">@angular/compiler-cli</a> - a drop-in replacement for <a href=\"https://www.npmjs.com/package/typescript\">tsc</a> which statically analyzes our application and emits TypeScript/JavaScript for the component’s templates.</li>\n<li><a href=\"https://github.com/mgechev/angular-seed\">angular2-seed</a> - a starter project which includes support for AoT compilation.</li>\n<li><a href=\"https://cli.angular.io/\">Angular CLI</a> Using the ng serve --prod</li>\n</ul>\n<h3>Resources</h3>\n<ul>\n<li><a href=\"http://blog.mgechev.com/2016/08/14/ahead-of-time-compilation-angular-offline-precompilation/\">Ahead-of-Time Compilation in Angular</a> by Minko Gechev</li>\n</ul>\n"
    },
    "FGjYL": {
      "id": "FGjYL",
      "slug": "use-on-push-cd-strategy",
      "category": "performance",
      "title": "use onPush CD strategy on dumb components",
      "content": "<h3>Problem</h3>\n<p>Change detection (CD) in Angular is performed from top to bottom. This means that everything is only checked once. This is a huge difference compared to AngularJS where change detection was performed in cycles until everything was considered stable.</p>\n<p>However, it still means that everything is checked every time CD is triggered, even things that we know for sure have not changed.</p>\n<h3>Solution</h3>\n<p>Angular components can use different strategies for change detection. They can either use <code>Default</code> or <code>OnPush</code>.</p>\n<p>The default strategy means that the component will be checked during every CD cycle.</p>\n<p>With the <code>OnPush</code> strategy, the component (and all of its children!) will only be checked if one of its <code>@Input</code>s have changed (reference check) <strong>or</strong> if an event was triggered within the component.</p>\n<p>This means that we can easily tell Angular to not run CD for huge parts of our component tree, speeding up CD a lot! We can enable the <code>OnPush</code> strategy like this:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@Component</span>({\n  ...\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\n</code></pre>\n<p><strong>Note 1:</strong> This also implies that we should always try to work immutable. Let’s say that we add an element to an array by mutating the array and we pass the array to a component to visualise it. If we apply the <code>OnPush</code> strategy for this component, we wouldn’t see the changes in the UI. Angular will not check if the array’s content has changed. It will only check the reference. As the reference has not changed, it means that CD will not run for that component and the view will not be updated.</p>\n<p><strong>Note 2:</strong> This also means that, every component we apply this strategy to, has to be dumb. If the component fetches its own data, we cannot have the <code>OnPush</code> strategy. Because in that case, the component’s <code>@Input</code>s wouldn’t be the only reason to run CD, but also data being fetched.</p>\n<p><strong>Note 3:</strong> When using the <code>async</code> pipe, it will automatically call <code>markForCheck</code> under the hood. This marks the path to that component as “to be checked”. When the next CD cycle kicks in, the path to that component is not disabled and the view will be updated.</p>\n<h3>Resources</h3>\n<ul>\n<li><a href=\"https://blog.thoughtram.io/angular/2016/02/22/angular-2-change-detection-explained.html\">Angular change detection explained</a> by Pascal Precht</li>\n<li><a href=\"https://blog.angularindepth.com/everything-you-need-to-know-about-change-detection-in-angular-8006c51d206f\">Everything you need to know about change detection in Angular</a> by Maxim Koretskyi</li>\n</ul>\n"
    },
    "Zy4xtr": {
      "id": "Zy4xtr",
      "slug": "add-404-route",
      "category": "router",
      "title": "add 404 fallback route",
      "content": "<h3>Problem</h3>\n<p>There are multiple reasons why we need to make sure that we have a fallback for when a page is not found.</p>\n<ul>\n<li>Our users are humans. Humans are quite error-prone. This means that they are likely to mistype a url at some point.</li>\n<li>Over time, our applications will change. Users might bookmark urls for pages which are not supported anymore.</li>\n</ul>\n<h3>Solution</h3>\n<p>Every application should define a 404 route. This is a route to be shown whenever the user tries to go to a non existing route.</p>\n<pre class=\"hljs\"><code>[\n  ...,\n  { path: <span class=\"hljs-string\">'404'</span>, component: NotFoundComponent },\n  { path: <span class=\"hljs-string\">'**'</span>, redirectTo: <span class=\"hljs-string\">'/404'</span> },\n]\n</code></pre>\n<p>The last route definition uses a wildcard as a path. Since the Angular router will render the first definitions that matches, be sure to always put this route definition last!</p>\n"
    },
    "5ScV4": {
      "id": "5ScV4",
      "slug": "default-route",
      "category": "router",
      "title": "make sure default route is defined",
      "content": "<h3>Problem</h3>\n<p>When users type in the url for your application, they do not know all the routes of our application. We need to make sure that we always have a landing page or a redirect set up.</p>\n<h3>Solution</h3>\n<p>Every application should define a default route. This is the route that will be used whenever the user goes to <code>/</code>.</p>\n<pre class=\"hljs\"><code>[\n  { path: <span class=\"hljs-string\">''</span>, redirectTo: <span class=\"hljs-string\">'/heroes'</span>, pathMatch: <span class=\"hljs-string\">'full'</span> },\n  ...\n]\n</code></pre>\n<p>Note that <code>pathMatch: full</code> should be used to make sure that this route definitions is only triggered when the user is going to <code>/</code>.</p>\n"
    },
    "Z165VzV": {
      "id": "Z165VzV",
      "slug": "lazy-load-feature-modules",
      "category": "router",
      "title": "lazy load feature modules",
      "content": "<h3>Problem</h3>\n<p>When working with SPAs, we need to ship an entire application to the client. The more bytes we need to ship, the slower it will be to load but also to parse. This will greatly influence the TTI (Time to Interactive) of our application.</p>\n<p>We are shipping way too much JavaScript to the client.</p>\n<h3>Solution</h3>\n<p>Angular provides us with a module system. When we break up our application in feature modules, we can leverage this to only load the modules that are needed for the first page render. The other modules can be lazily loaded only when they are needed. We can do this, when the user requests them or via a more sophisticated preloading strategy.</p>\n<p>The following module is <strong>not</strong> using lazy loading to load the <code>UsersModule</code>.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// app.routing.ts</span>\n<span class=\"hljs-keyword\">const</span> routes: Routes = [\n  ...\n  {path: <span class=\"hljs-string\">'users'</span>, component: UsersComponent}\n  ...\n];\n\n<span class=\"hljs-comment\">// app.module.ts</span>\n<span class=\"hljs-meta\">@NgModule</span>({\n  declarations: [AppComponent],\n  imports: [\n    ...\n    UsersModule,\n    RouterModule.forRoot(routes),\n  ],\n  bootstrap: [AppComponent]\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> AppModule {}\n</code></pre>\n<p>This means that the <code>UsersModule</code> will be added to the main bundle. The main bundle contains all the code that is needed for the first page load. As the <code>UsersModule</code> is only needed when the user specifically navigates to the <code>/users</code> page, it doesn’t make sense to load it up front. Let’s leverage lazy loading to fix this.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// app.routing.ts</span>\n<span class=\"hljs-keyword\">const</span> routes: Routes = [\n  ...\n  {\n    path: <span class=\"hljs-string\">'users'</span>,\n    loadChildren: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\">'../users/usersModule'</span>).then(<span class=\"hljs-function\"><span class=\"hljs-params\">m</span> =&gt;</span> m.UsersModule)\n  }\n  ...\n];\n\n<span class=\"hljs-comment\">// app.module.ts</span>\n<span class=\"hljs-meta\">@NgModule</span>({\n  declarations: [AppComponent],\n  imports: [\n    ...\n    RouterModule.forRoot(routes),\n  ],\n  bootstrap: [AppComponent]\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> AppModule {}\n</code></pre>\n<p>We updated the <code>/users</code> route to use the <code>loadChildren</code> property. This uses the standard dynamic import syntax.\nCalled as a function, the import returns a promise which loads the module.</p>\n<p>Also note that we no longer add the <code>UsersModule</code> to the imports of the <code>AppModule</code>. This is important because otherwise lazy loading wouldn’t work as expected. If the <code>UsersModule</code> was referenced by the <code>AppModule</code> the code for that module would be added to the main bundle.</p>\n<p>By using <code>loadChildren</code> and removing the module import from the <code>AppModule</code>, the <code>UsersModule</code> will be packaged in its own bundle and will only be loaded when the user navigates to <code>/users</code>.</p>\n<h3>Resources</h3>\n<p><a href=\"https://medium.com/@addyosmani/the-cost-of-javascript-in-2018-7d8950fbb5d4\">The cost of JavaScript</a> by Addy Osmani</p>\n"
    },
    "Z2nRe1e": {
      "id": "Z2nRe1e",
      "slug": "protect-restricted-pages-with-guards",
      "category": "router",
      "title": "protect restricted pages with guards",
      "content": "<h3>Problem</h3>\n<p>Users should not be able to access pages that they don’t have access to. We could hide the menu item so they could not navigate to it by clicking on that menu item but this means they can still manually type in the url to go to that page. We need some way to protect certain routes.</p>\n<h3>Solution</h3>\n<p>We can use guards to allow or deny route changes. Every part of your application that should be limited to users with certain roles should be protected with guards.</p>\n<p>We can create a guard by creating a service that implements the <code>CanActivate</code> interface to avoid users going to a certain component or a <code>canLoad</code> interface to avoid entire modules to be loaded.</p>\n<p>The following example shows how to use a <code>canActivate</code> guard.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@Injectable</span>()\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> UserHasRoleGuard <span class=\"hljs-keyword\">implements</span> CanActivate {\n  <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">private</span> activatedRoute</span>) {}\n\n  canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot) {\n    <span class=\"hljs-comment\">// return an Observable&lt;boolean&gt; | Promise&lt;boolean&gt; | boolean;</span>\n  }\n}\n</code></pre>\n<p>We can now use it in our route definitions:</p>\n<pre class=\"hljs\"><code>[\n  ...,\n  { path: <span class=\"hljs-string\">'users'</span>, component: UsersComponent, canActivate: [UserHasRoleGuard] },\n]\n</code></pre>\n<p>You can see that the <code>canActivate</code> property on the route definition takes an array. This means we can add multiple guards which will be called chronologically in the order they are defined.</p>\n"
    },
    "lGMp8": {
      "id": "lGMp8",
      "slug": "use-preloading-strategy",
      "category": "router",
      "title": "use preloading strategy",
      "content": "<h3>Problem</h3>\n<p>When we use lazy loading, we are only loading the code that is needed for the first page render. Modules that are not yet needed are not loaded.</p>\n<p>By default, the next modules will be loaded whenever the user requests them. This is not ideal in every scenario because it means that whenever a user requests a url, they have to wait until the module is loaded and parsed.</p>\n<h3>Solution</h3>\n<p>Depending on the application you are building and whether you have to deal with low bandwidth, it might be better to use a different strategy other than loading modules on request.</p>\n<p>When working on an application that will be used only on a steady WiFi connection, it makes sense to preload all of the modules when the CPU is idle. If our application will be used mainly on a slow 3G connection, we should only load the modules that are most likely used.</p>\n<h4>Load all modules after first page render</h4>\n<p>One strategy provided by the Angular team is to preload all modules when the CPU becomes idle. This means that, after the first page render, the modules will all be loaded in the background.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@NgModule</span>({\n  imports: [\n    ...modules,\n    RouterModule.forRoot(routes, {\n      preloadingStrategy: PreloadAllModules\n    })\n  ],\n  ...\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> AppModule {}\n</code></pre>\n<h4>Defining a custom preloading strategy</h4>\n<p>If our users can be both on mobile and on WiFi, it might make sense to only preload the modules if they are on WiFi. To do this, we can implement a custom preloading strategy.</p>\n<p>A custom preloading strategy is implemented as a class and implements the <code>PreloadingStrategy</code> interface.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// custom.preloading-strategy.ts</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> MyCustomPreloadingStrategy <span class=\"hljs-keyword\">implements</span> PreloadingStrategy {\n  preload(route: Route, load: <span class=\"hljs-built_in\">Function</span>): Observable&lt;<span class=\"hljs-built_in\">any</span>&gt; {\n    <span class=\"hljs-comment\">// Implement your strategy here</span>\n  }\n}\n\n<span class=\"hljs-comment\">// app.module.ts</span>\n<span class=\"hljs-meta\">@NgModule</span>({\n  imports: [\n    ...modules,\n    <span class=\"hljs-comment\">// Custom Preloading Strategy</span>\n    RouterModule.forRoot(routes, { preloadingStrategy: MyCustomPreloadingStrategy });\n  ],\n  ...\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> AppModule {}\n</code></pre>\n<h4>Data-driven bundling</h4>\n<p>Another way is to use <a href=\"https://github.com/guess-js/guess\">Guess.js</a>, a data-driven bundling approach. The goal with Guess.js is to minimize the bundle layout configuration, make it data-driven, and much more accurate. Guess.js will will figure out which bundles to be combined together and what pre-fetching mechanism to be used.</p>\n<p>Guess.js can also be used with the Angular CLI. Here’s an <a href=\"https://github.com/mgechev/guess-js-angular-demo\">example</a>.</p>\n<h3>Resources</h3>\n<ul>\n<li><a href=\"https://vsavkin.com/angular-router-preloading-modules-ba3c75e424cb\">Angular Router: Preloading Modules</a> by Victor Savkin</li>\n<li><a href=\"https://blog.mgechev.com/2018/05/09/introducing-guess-js-data-driven-user-experiences-web/\">Introducing Guess.js - a toolkit for enabling data-driven user-experiences on the Web</a> by Minko Gechev</li>\n</ul>\n"
    },
    "Z1eFwa9": {
      "id": "Z1eFwa9",
      "slug": "avoid-nested-subscriptions",
      "category": "rxjs",
      "title": "avoid nested subscriptions",
      "content": "<h3>Problem</h3>\n<p>Sometimes we need to aggregate values from multiple observables or deal with nested observables to perform an action. In that case, you could  subscribe to an observable in the subscribe block of another observable. This makes handling subscriptions way more difficult and feels like callback hell all over again.</p>\n<h3>Solution</h3>\n<p>For aggregating values or dealing with nested observables we can use one of the combination or flattening operators.</p>\n<p>Let’s consider the following example: In an e-commerce system we are fetching a product and based on that product we want to fetch similar ones.</p>\n<p>A naive solution could look like this:</p>\n<pre class=\"hljs\"><code>fetchProduct(<span class=\"hljs-number\">1</span>).subscribe(<span class=\"hljs-function\"><span class=\"hljs-params\">product</span> =&gt;</span> {\n  fetchSimilarProducts(product).subscribe(<span class=\"hljs-function\"><span class=\"hljs-params\">similarProducts</span> =&gt;</span> {\n    ...\n  });\n});\n</code></pre>\n<p>We first fetch the product and once the request is resolved we fetch similar products inside the subscribe block of the first, most outer observable.</p>\n<p>This is considered to be an anti-pattern or code smell for the following reasons:</p>\n<ul>\n<li>👹 it brings us back to callback hell,</li>\n<li>💔 it breaks Reactive Programming,</li>\n<li>🐢 it breaks observables laziness,</li>\n<li>💥 it doesn’t help with subscription management,</li>\n<li>🤢 it’s ugly anyway.</li>\n</ul>\n<p>Instead we can use one of the flattening operators to get rid of this code smell and solve it more elegantly:</p>\n<pre class=\"hljs\"><code>fetchProduct(<span class=\"hljs-number\">1</span>).pipe(\n  switchMap(<span class=\"hljs-function\"><span class=\"hljs-params\">product</span> =&gt;</span> fetchSimilarProducts(product))\n).subscribe(...)\n</code></pre>\n<p>Here’s another example: A simple list view where the user can filter and paginate the list. Whenever the user goes to the next page we also need to take into account the filter:</p>\n<p>Naive solution:</p>\n<pre class=\"hljs\"><code>nextPage$.subscribe(<span class=\"hljs-function\"><span class=\"hljs-params\">page</span> =&gt;</span> {\n  filter$.pipe(take(<span class=\"hljs-number\">1</span>)).subscribe(<span class=\"hljs-function\"><span class=\"hljs-params\">filter</span> =&gt;</span> {\n    fetchData(page, filter).subscribe(<span class=\"hljs-function\"><span class=\"hljs-params\">items</span> =&gt;</span> {\n      <span class=\"hljs-keyword\">this</span>.items = items;\n    });\n  });\n});\n</code></pre>\n<p>That’s again not the most idiomatic solution because we have introduced several nested subscriptions.</p>\n<p>Let’s fix this with a combination and flattening operator:</p>\n<pre class=\"hljs\"><code>nextPage$\n  .pipe(\n    withLatestFrom(filter$),\n    switchMap(<span class=\"hljs-function\">(<span class=\"hljs-params\">[page, filter]</span>) =&gt;</span> fetchData(page, filter))\n  )\n  .subscribe(<span class=\"hljs-function\"><span class=\"hljs-params\">items</span> =&gt;</span> {\n    <span class=\"hljs-keyword\">this</span>.items = items;\n  });\n</code></pre>\n<p>Or when we want to listen for changes in both the <code>nextPage$</code> and the <code>filter$</code> we could use <code>combineLatest</code>:</p>\n<pre class=\"hljs\"><code>combineLatest(nextPage$, filter$)\n  .pipe(switchMap(<span class=\"hljs-function\">(<span class=\"hljs-params\">[page, filter]</span>) =&gt;</span> fetchData(page, filter)))\n  .subscribe(<span class=\"hljs-function\"><span class=\"hljs-params\">items</span> =&gt;</span> {\n    <span class=\"hljs-keyword\">this</span>.items = items;\n  });\n</code></pre>\n<p>Both solutions are much more readable and they also reduces the complexity of our code.</p>\n<p>Here are some very common combination and flattening operators:</p>\n<p><strong>Combination Operators</strong>:</p>\n<ul>\n<li><code>combineLatest</code></li>\n<li><code>withLatestFrom</code></li>\n<li><code>merge</code></li>\n<li><code>concat</code></li>\n<li><code>zip</code></li>\n<li><code>forkJoin</code></li>\n<li><code>pairwise</code></li>\n<li><code>startWith</code></li>\n</ul>\n<p><strong>Flattening Operators</strong>:</p>\n<ul>\n<li><code>switchMap</code></li>\n<li><code>mergeMap</code></li>\n<li><code>concatMap</code></li>\n<li><code>exhaustMap</code></li>\n</ul>\n"
    },
    "ZzpwmT": {
      "id": "ZzpwmT",
      "slug": "pipeable-operators",
      "category": "rxjs",
      "title": "use pipeable operators",
      "content": "<h3>Problem</h3>\n<p>Since the release of RxJS 6, patch operators have been removed. This means that we can no longer use them.</p>\n<p>This means the following is no longer possible:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'rxjs/add/observable/interval'</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'rxjs/add/operator/map'</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'rxjs/add/operator/filter'</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'rxjs/add/operator/switchMap'</span>;\n\nObservable.interval(<span class=\"hljs-number\">1000</span>)\n  .filter(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> x % <span class=\"hljs-number\">2</span> === <span class=\"hljs-number\">0</span>)\n  .map(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> x*<span class=\"hljs-number\">2</span>)\n  .switchMap(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> mapToObservable(x))\n</code></pre>\n<h3>Solution</h3>\n<p>Instead, we should be using pipeable operators.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> { interval } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rxjs'</span>;\n<span class=\"hljs-keyword\">import</span> { filter, map, switchMap } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rxjs/operators'</span>;\n\nObservable.interval(<span class=\"hljs-number\">1000</span>)\n  .pipe(\n    filter(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> x % <span class=\"hljs-number\">2</span> === <span class=\"hljs-number\">0</span>),\n    map(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> x*<span class=\"hljs-number\">2</span>),\n    switchMap(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> mapToObservable(x)),\n  );\n</code></pre>\n<p>Even if you are using the older versions of RxJS, all new code should be written using pipeable operators.</p>\n<h4>Upgrading</h4>\n<p>If you have a lot of code written using patch operators, you can use a script released written by Google engineers to do this upgrade automatically for you. You can find the script and how to use it in the <a href=\"https://github.com/ReactiveX/rxjs-tslint#migration-to-rxjs-6\">rxjs-tslint</a> package.</p>\n"
    },
    "Iqkhs": {
      "id": "Iqkhs",
      "slug": "takeuntil-operator",
      "category": "rxjs",
      "title": "don't manage subscriptions imperatively",
      "content": "<h3>Problem</h3>\n<p>When we subscribe to an Observable, we also need to unsubscribe to clean up its resources. Unsubscribing can be done like this:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// hold a reference to the subscription object</span>\n<span class=\"hljs-keyword\">const</span> subscription = interval(<span class=\"hljs-number\">1000</span>).subscribe(<span class=\"hljs-built_in\">console</span>.log);\n\n<span class=\"hljs-comment\">// use the subscription object to kill the subscription</span>\nsubscription.unsubscribe();\n</code></pre>\n<p>But if we have multiple subscriptions, we need to manage all of them. We could do this in an array but this gets extremely verbose. We want to avoid having to do this imperatively.</p>\n<h3>Solution</h3>\n<p>RxJS provides us with the <code>takeUntil</code> operator, and a few other conditional operators. This operator will mirror the source observable until a certain event happens. In most cases, we want to stop listening to Observables when the component gets destroyed. This allows us to write something like this:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@Component</span>({...})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> SomeComponent <span class=\"hljs-keyword\">implements</span> OnInit, OnDestroy {\n  <span class=\"hljs-keyword\">private</span> destroy$ = <span class=\"hljs-keyword\">new</span> Subject();\n  users: <span class=\"hljs-built_in\">Array</span>&lt;User&gt;;\n\n  <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">private</span> usersService: UsersService</span>) {}\n\n  ngOnInit() {\n    <span class=\"hljs-comment\">// long-living stream of users</span>\n    <span class=\"hljs-keyword\">this</span>.usersService.getUsers()\n     .pipe(\n       takeUntil(<span class=\"hljs-keyword\">this</span>.destroy$)\n     )\n     .subscribe(\n       <span class=\"hljs-function\"><span class=\"hljs-params\">users</span> =&gt;</span> <span class=\"hljs-keyword\">this</span>.users = users;\n     );\n   }\n\n   ngOnDestroy() {\n     <span class=\"hljs-keyword\">this</span>.destroy$.next();\n   }\n}\n</code></pre>\n<p>We create a <code>Subject</code> called <code>destroy$</code> and when the <code>ngOnDestroy</code> hook is called, we <code>next</code> a value onto the subject.</p>\n<p>The manual subscribe we defined in the <code>ngOnInit</code> hook uses the <code>takeUntil</code> operator in combination with our subject. This means that the subscription will remain active <strong>until</strong> <code>destroy$</code> emits a value. After that, it will unsubscribe from the source stream and complete it.</p>\n<p>This is a lot better than imperatively handling the subscriptions.</p>\n<p><strong>Note:</strong> Using the <code>async</code> pipe is even better as we don’t have to think about this at all. It will hook into the destroy lifecycle hook and unsubscribe for us.</p>\n<h3>Resources</h3>\n<ul>\n<li><a href=\"https://medium.com/@benlesh/rxjs-dont-unsubscribe-6753ed4fda87\">RxJS: don’t unsubscribe</a> by Ben Lesh</li>\n<li><a href=\"https://blog.angularindepth.com/rxjs-avoiding-takeuntil-leaks-fb5182d047ef\">RxJS: Avoiding takeUntil leaks</a> by Nicholas Jamieson</li>\n</ul>\n"
    },
    "Z3uGQp": {
      "id": "Z3uGQp",
      "slug": "use-async-pipe",
      "category": "rxjs",
      "title": "use the async pipe",
      "content": "<h3>Problem</h3>\n<p>In Angular, everything async is handled by Observables and they are triggered by subscribing to them. Whenever we do so, it is very important to also unsubscribe. Unsubscribing will clean up the resources being used by this stream. If we neglect to do this, we might introduce memory leaks.</p>\n<p>If we manually subscribe, it also means that we have to manually unsubscribe. This is something that is easily forgotten.</p>\n<h3>Solution</h3>\n<p>Instead of manually subscribing, we can use the <code>async</code> pipe provided by Angular.</p>\n<p>The async pipe will:</p>\n<ul>\n<li>subscribe to an Observable</li>\n<li>unsubscribe from the Observable when the component is destroyed by hooking into the <code>onDestroy</code> hook</li>\n<li>mark this component as “to be checked” for the next change detection cycle</li>\n</ul>\n<p>Using the <code>async</code> pipe as much as possible will make sure all the resources are cleaned up properly and reduce the likelihood of memory leaks.</p>\n<p>Here’s an example:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@Component</span>({\n  template: <span class=\"hljs-string\">`{{data$ | async}}`</span>,\n  ...\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> SomeComponent {\n  data$ = interval(<span class=\"hljs-number\">1000</span>);\n}\n</code></pre>\n<p>Here, we set up an <code>interval</code> that emits a value every second. This is a long-living Observable and because we are using the <code>async</code> pipe, the resource (subscription) is cleaned up when the component is destroyed.</p>\n<h3>Resources</h3>\n<p><a href=\"https://blog.thoughtram.io/angular/2017/02/27/three-things-you-didnt-know-about-the-async-pipe.html\">Three things you didn’t know about the async pipe</a> by Christoph Burgdorf</p>\n"
    },
    "fztee": {
      "id": "fztee",
      "slug": "use-ngifas",
      "category": "rxjs",
      "title": "use ngIfAs to subscribe only once",
      "content": "<h3>Problem</h3>\n<p>An Observable is lazy and unicast by default. This means that for every subscription, the Observable is executed. If the Observable is triggering a backend call when subscribed to, the following code will trigger two backend calls.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@Component</span>({\n  &lt;some-component data=<span class=\"hljs-string\">\"data$ | async\"</span>&gt;&lt;<span class=\"hljs-regexp\">/some-component&gt;\n  &lt;some-other-component data=\"data$ | async\"&gt;&lt;/</span>some-component&gt;\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> SomeComponent <span class=\"hljs-keyword\">implements</span> OnInit, OnDestroy {\n  data$;\n  ...\n}\n</code></pre>\n<p>This is not the intended behavior. We want to fetch the data only once.</p>\n<h3>Solution</h3>\n<p>We can fix this problem in multiple ways, either with the <code>ngIfAs</code> syntax, or by making our Observable hot.</p>\n<h4>ngIfAs syntax</h4>\n<p>We can use an <code>*ngIf</code> to hide an element. We can also leverage it to <em>unpack</em> an observable and bind the value to a variable. We can then use that variable inside of the template.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@Component</span>({\n  &lt;div *ngIf=<span class=\"hljs-string\">\"data$ | async as data\"</span>&gt;\n    &lt;some-component data=<span class=\"hljs-string\">\"data\"</span>&gt;&lt;<span class=\"hljs-regexp\">/some-component&gt;\n    &lt;some-other-component data=\"data\"&gt;&lt;/</span>some-component&gt;\n  &lt;<span class=\"hljs-regexp\">/div&gt;\n})\nexport class SomeComponent implements OnInit, OnDestroy {\n  data$;\n  ...\n}\n</span></code></pre>\n<p>By wrapping the components with a div that hides the element if no data is present, we were able to reduce the number of subscriptions from 2 to 1. This means that we only have a single subscription. Using the <code>as</code> syntax, we can also <em>catch</em> the event from that observable and bind it to a variable and use that variable to pass it to our components.</p>\n<p>Better yet, if we don’t want to introduce another level of nesting, we can use the <code>&lt;ng-container&gt;</code> element. This elements lets us group sibling elements under an invisible container element that is not rendered.</p>\n<p>Here’s what the code from above looks like using <code>&lt;ng-container&gt;</code>:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@Component</span>({\n  &lt;ng-container *ngIf=<span class=\"hljs-string\">\"data$ | async as data\"</span>&gt;\n    &lt;some-component data=<span class=\"hljs-string\">\"data\"</span>&gt;&lt;<span class=\"hljs-regexp\">/some-component&gt;\n    &lt;some-other-component data=\"data\"&gt;&lt;/</span>some-component&gt;\n  &lt;<span class=\"hljs-regexp\">/ng-container&gt;\n})\nexport class SomeComponent implements OnInit, OnDestroy {\n  data$;\n  ...\n}\n</span></code></pre>\n<p>Now, the template will be rendered as:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">some-component</span> <span class=\"hljs-attr\">data</span>=<span class=\"hljs-string\">\"data\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">some-component</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">some-other-component</span> <span class=\"hljs-attr\">data</span>=<span class=\"hljs-string\">\"data\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">some-component</span>&gt;</span>\n</code></pre>\n<h4>Make the Observable hot</h4>\n<p>We can also make our Observable hot so that the Observable will no longer trigger a backend call with every subscription. A hot Observable will share the underlying subscription so the source Observable is only executed once.</p>\n<p>This fixes our problem because it means it doesn’t matter anymore if we have multiple subscriptions.</p>\n<p>To do this, we can use for example the <code>shareReplay</code> operator.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@Component</span>({\n  &lt;some-component data=<span class=\"hljs-string\">\"sharedData$ | async\"</span>&gt;&lt;<span class=\"hljs-regexp\">/some-component&gt;\n  &lt;some-other-component data=\"sharedData$ | async\"&gt;&lt;/</span>some-component&gt;\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> SomeComponent <span class=\"hljs-keyword\">implements</span> OnInit, OnDestroy {\n  sharedData$ = data$.pipe(\n    shareReplay({ bufferSize: <span class=\"hljs-number\">1</span>, refCount: <span class=\"hljs-literal\">true</span> })\n  );\n  ...\n}\n</code></pre>\n<blockquote>\n<p>Note: we should specify <code>refCount: true</code> to prevent possible memory leaks.</p>\n</blockquote>\n<h3>Resources</h3>\n<ul>\n<li><a href=\"https://blog.strongbrew.io/multicasting-operators-in-rxjs/\">Multicasting operators in RxJS</a> by Kwinten Pisman</li>\n</ul>\n"
    },
    "Z1vCEKO": {
      "id": "Z1vCEKO",
      "slug": "use-switchMap-only-when-you-need-cancellation",
      "category": "rxjs",
      "title": "use switchMap only when you need cancellation",
      "content": "<h3>Problem</h3>\n<p>In certain scenarios, using the wrong flattening operators from RxJS can result in unwanted behavior and race conditions.</p>\n<h3>Solution</h3>\n<p>For example, in an e-commerce application users can add and remove items from their shopping cart. The logic for removing an item could look like this:</p>\n<pre class=\"hljs\"><code>removeItemButtonClick.pipe(\n  switchMap(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> <span class=\"hljs-keyword\">this</span>.backend.removeFromCart(item.id))\n)\n</code></pre>\n<p>Whenever the user clicks on the button to remove a certain item from the shopping cart, this action is forwarded to the application’s backend. Most of the times this works as expected. However, the behavior depends on how rapidly items are removed from the cart. For example, either all items could be removed, or only some of them.</p>\n<p>In this example, <code>switchMap</code> is not the right operator because for every new action it will abort / cancel the previous action. This behavior makes <code>switchMap</code> unsafe for create, update and delete actions.</p>\n<p>There are several other flattening operators that may be more appropriate:</p>\n<ul>\n<li><code>mergeMap</code>: concurrently handle all emissions</li>\n<li><code>concatMap</code>: handle emissions one after the other</li>\n<li><code>exhaustMap</code>: when you want to cancel new emissions while processing a previous emission</li>\n</ul>\n<p>So we could fix the problem from above by <code>mergeMap</code>:</p>\n<pre class=\"hljs\"><code>removeItemButtonClick.pipe(\n  mergeMap(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> <span class=\"hljs-keyword\">this</span>.backend.removeFromCart(item.id))\n)\n</code></pre>\n<p>If the order is important we could use <code>concatMap</code>.</p>\n<p>For more information see the article from <a href=\"https://twitter.com/ncjamieson\">Nicholas Jamieson</a> listed below.</p>\n<h3>Resources</h3>\n<ul>\n<li><a href=\"https://blog.angularindepth.com/switchmap-bugs-b6de69155524\">RxJS: Avoiding switchMap-Related Bugs</a> by Nicholas Jamieson</li>\n</ul>\n"
    },
    "Z1uf1Rj": {
      "id": "Z1uf1Rj",
      "slug": "compodoc",
      "category": "tooling",
      "title": "use compodoc for documentation",
      "optional": true,
      "content": "<h3>Problem</h3>\n<p>On boarding of new developers in your project can be quite difficult. Especially if the applications are getting bigger and bigger.</p>\n<p>When the project becomes really big, even for developers that have been working on it for a long time, keeping an overview is not that easy.</p>\n<h3>Solution</h3>\n<p>Documentation for our code is the solution to this problem. Of course, everyone knows that writing documentation is hard, boring and the documentation itself gets out of date quite quickly.</p>\n<p>To fix this, we can use compodoc to generate documentation from our code. This means that it doesn’t take any time to write and it can never get out of date as it is generated from the existing code at all times.</p>\n<h3>Resources</h3>\n<ul>\n<li><a href=\"https://compodoc.app/\">Compodoc</a></li>\n</ul>\n"
    },
    "Z2fVpC5": {
      "id": "Z2fVpC5",
      "slug": "use-angular-cli",
      "category": "tooling",
      "title": "use @angular/cli",
      "optional": true,
      "content": "<h3>Problem</h3>\n<p>When we ship our code to the browsers, our code needs to be optimised, bundled, minified, uglified and much more. There are also other steps involved in a proper build process. This can be quite a difficult and cumbersome task to do and especially to maintain.</p>\n<h3>Solution</h3>\n<p>To fix this, we should use the <code>@angular/cli</code> to take over the build process. The Angular CLI simplifies the development of your Angular applications drastically. Aside from the build process, the CLI also provides you with code scaffolding which you can use to easily generate entire projects, components and much more.</p>\n<p>The CLI abstracts everything for us. This also means that when there are better solutions available to for example perform the build process, and if they integrate this, we get this update without putting any effort in. Since version 6, it also possible to hook into the entire build process via builders.</p>\n<h3>Resources</h3>\n<ul>\n<li><a href=\"https://cli.angular.io/\">Angular CLI</a></li>\n<li><a href=\"https://medium.com/dailyjs/angular-cli-6-under-the-hood-builders-demystified-f0690ebcf01\">Angular CLI under the hood - builders demystified</a> by Evgeny Barabanov</li>\n</ul>\n"
    },
    "PWWcx": {
      "id": "PWWcx",
      "slug": "use-prettier",
      "category": "tooling",
      "title": "use prettier for code formatting",
      "content": "<h3>Problem</h3>\n<p>Whenever we write code, we want this code to be formatted in a standardised way. This poses two problems.</p>\n<ul>\n<li>We need to align everyone in the team to agree with the same standards.</li>\n<li>We need to get all of their IDE’s/editors aligned as well. This can be extremely difficult.</li>\n</ul>\n<h3>Solution</h3>\n<p>Prettier is an opinionated code formatter that can fix both of these problems. It imposes a standard way of formatting and it has a CLI that makes sure the formatting happens the same way on all environments. Adding Prettier and running it as a pre-commit hook will make sure only formatted code can be checked in.</p>\n<h3>Resources</h3>\n<ul>\n<li><a href=\"https://prettier.io/\">Prettier</a></li>\n<li><a href=\"https://github.com/schuchard/prettier-schematic\">Add prettier to Angular CLI schematic</a></li>\n</ul>\n"
    },
    "Z2hzSxp": {
      "id": "Z2hzSxp",
      "slug": "avoid-using-any",
      "category": "typescript",
      "title": "avoid using any",
      "content": "<h3>Problem</h3>\n<p>TypeScript allows us to write code that is statically type checked. This provides huge benefits. It helps us during development with auto completion, it simplifies working with third party libraries, helps us to refactor our code, spots errors during development that would have otherwise been runtime errors and much more.</p>\n<p>If we start using the <code>any</code> type, we lose all these benefits.</p>\n<h3>Solution</h3>\n<p>The solution is to avoid the <code>any</code> type wherever possible in our code and we should define proper types instead.</p>\n<p>Here’s a classic example:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">var</span> x: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">10</span>;\n<span class=\"hljs-keyword\">var</span> y: <span class=\"hljs-built_in\">any</span> = <span class=\"hljs-string\">\"a\"</span>;\nx = y;\n</code></pre>\n<p>See how we assign a string to <code>x</code> although <code>x</code> is defined as a <code>number</code>? That’s a nightmare.</p>\n<p>Let’s look at another example:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> x: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">10</span>;\n<span class=\"hljs-keyword\">const</span> y: <span class=\"hljs-built_in\">any</span> = <span class=\"hljs-string\">'a'</span>;\n<span class=\"hljs-keyword\">const</span> z = x + y;\n\n<span class=\"hljs-comment\">// Prints out 10a</span>\n<span class=\"hljs-built_in\">console</span>.log(z);\n</code></pre>\n<p>In the last example we add <code>x</code> and <code>y</code> together, and typing <code>y</code> as <code>any</code>, TypeScript cannot really help us and avoid this bug at development time. Basically, we end up with a concatenation and we’re essentially back in JavaScriptLand.</p>\n<h4>Compiler Options</h4>\n<p>Set the compiler <code>–noImplicitAny</code> flag. With this flag enabled the compiler will complain if anything has an implicit type of <code>any</code>.</p>\n<h4>3rd party libraries</h4>\n<p>When working with 3rd party libraries that are written in vanilla JavaScript, we most likely don’t have type information available. Luckily there is an initiative to create type definitions for those libraries. If it exists, you can find it by installing the type package via <code>yarn add --dev @types/${library-name}</code>.</p>\n<p>If this does not exist yet, you can create one yourself. Contributions are always welcome and appreciated.</p>\n"
    },
    "23KPo0": {
      "id": "23KPo0",
      "slug": "define-interfaces-for-models",
      "category": "typescript",
      "title": "define interfaces for models",
      "content": "<h3>Problem</h3>\n<p>TypeScript helps us to create type safe code. When working with REST APIs, we will get back data (a DTO) at runtime that has a specific format. In case we don’t define types in our code for the objects we expect to get back, we lose the benefit of TypeScript.</p>\n<h3>Solution</h3>\n<p>We should define our models or DTOs (Data Transfer Objects) as interfaces instead of classes. Interfaces are virtual structures that only exist within the context of TypeScript. This means an interface does not generate code whereas a class is primarily syntactical sugar over JavaScript’s existing prototype-based inheritance. Consequently, a class generates code when it’s compiled to JavaScript.</p>\n<p>For example, if we make a backend request that will return an a user object with the properties <code>userName</code> and <code>password</code>, both strings, we can define an interface <code>User</code> that describes the shape of the response:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">interface</span> User {\n  userName: <span class=\"hljs-built_in\">string</span>;\n  password: <span class=\"hljs-built_in\">string</span>;\n}\n</code></pre>\n"
    },
    "12Aq23": {
      "id": "12Aq23",
      "slug": "define-types-at-the-non-typed-boundaries",
      "category": "typescript",
      "title": "define types at the non-typed boundaries",
      "content": "<h3>Problem</h3>\n<p>All our JavaScript code is written in TypeScript. This means that we can leverage types. However, our codes interacts with different non-typed boundaries such as the HTML layer (think of events) and backend requests. Interacting with these boundaries influences the type safety of our code.</p>\n<h3>Solution</h3>\n<p>When interacting with these boundaries, it is important to add type information so TypeScript knows the structure of the objects we are dealing with. By providing the type right at the boundary, TypeScript is able to infer it everywhere else where that variable is being used.</p>\n<p>For example when working with custom events:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@Component</span>({\n  template: <span class=\"hljs-string\">`&lt;some-other-component (someEvent)=\"someEventHandler($event)\"&gt;&lt;/some-other-component&gt;`</span>\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> SomeComponent {\n  someEventHandler(event: TypeForThisEvent) {\n    ...\n  }\n}\n</code></pre>\n<p><code>TypeForThisEvent</code> will make sure that the non-typed HTML event is typed inside of our TypeScript code.</p>\n"
    },
    "ZRBVWY": {
      "id": "ZRBVWY",
      "slug": "move-common-types-to-interfaces",
      "category": "typescript",
      "title": "move common types to interfaces",
      "content": "<h3>Problem</h3>\n<p>With Typescript, we can easily add types to our code like this:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">let</span> user: { userName: <span class=\"hljs-built_in\">string</span>; password: <span class=\"hljs-built_in\">string</span> };\n</code></pre>\n<p>In this case, we defined the type of our user <em>inline</em>. While this is a valid option, it also means that it’s not reusable. We could define it in multiple places. The downside here is that, when it is updated, we have to update multiple places.</p>\n<h3>Solution</h3>\n<p>Whenever a type is reused in multiple places, it is recommended to move it into a separate interface.</p>\n<p>For example, we could define an interface <code>User</code>:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">interface</span> User {\n  userName: <span class=\"hljs-built_in\">string</span>;\n  password: <span class=\"hljs-built_in\">string</span>;\n}\n</code></pre>\n"
    },
    "ZEhkug": {
      "id": "ZEhkug",
      "slug": "use-type-inference",
      "category": "typescript",
      "title": "use type inference",
      "content": "<h3>Problem</h3>\n<p>Typescript is really good at inferring the types in our code. Whenever it can do that, we don’t have to add the types ourselves.</p>\n<p>If we do add them everywhere, it doesn’t only take a lot of time, but it also means that we have to update them everywhere whenever anything changes.</p>\n<h3>Solution</h3>\n<p>In TypeScript, we want to take advantage of type inference as much as possible. TypeScript uses this to to provide type information when there is no explicit type annotation.</p>\n<p>Here’s an example:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> x: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">3</span>;\n<span class=\"hljs-keyword\">const</span> y: <span class=\"hljs-built_in\">string</span> = <span class=\"hljs-string\">'typescript will automatically infer the string type'</span>;\n</code></pre>\n<p>In both cases, the type is inferred when initializing the variables.</p>\n<p>To keep this code clean, we can omit the type information and use the type inference to automatically provide type information.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> x = <span class=\"hljs-number\">3</span>;\n<span class=\"hljs-keyword\">const</span> y = <span class=\"hljs-string\">'typescript will automatically infer the string type'</span>;\n</code></pre>\n<p>Type inference does not only take place when initializing variables but also when initializing class members, setting parameter default values, and determining function return types.</p>\n"
    }
  }
}